{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"udrone - QA done right \u00b6 Udrone is a system that allows you to remotely control N drones. The N drones can be sent a number of different commands. Based on these commands the drone will perform a number of actions and report the result back to the drone host controller. The system consists of a number of files on the controller side. udronerc.py - the core component. This code establishes a communication channel to the drone. qa.py - this is a wrapper for udrone.py that allows us to write test in json syntax and run them in a sane manner *.yml - this is a collection of predefined tests, that the drone can run Setup \u00b6 The following steps explain how to setup an udrone environment. Where do I get udrone \u00b6 Checkout the latest version via the following command $ git clone https://github.com/blogic/udrone How do I setup udrone software \u00b6 udrone is easy to setup. All custom information is stored in a central file called config.py $ cat config.py ifname: eth0 # the interface used to talk to the drones Hardware setup \u00b6 In addition to the device under testing (DUT) you will need N drones. A drone is a OpenWrt router with the udrone package installed. Once you have all devices, you need to set them up in 1 of the following ways. LAPTOP (eth0) -> (LAN) DRONE (WAN) -> (LAN) DUT (WAN) -> BACKEND LAPTOP (eth0) -> (LAN) DRONE (WIFI) -> (WIFI) DUT (WAN) -> BACKEND If you want to use more than just 1 Drone you will need to switches between LAPTOP/DRONE and DRONE/DUT . As a backend you will need, depending on the test: AP/PPPoE Server/DHCP/DNS/... Run tests \u00b6 The simplest test is the connectivity test. This will make the drone grab an IPV4 using DHCP from the DUT and wget http://openwrt.org/index.html . $ ./qa.py test/connectivity.yml Once all test are run, the qa tool will report back if the test passed or failed. Definition of test cases \u00b6 So, lets start by looking at the format of the json file. The basic layout of any json based test description is as follows { \"id\":\"The ID of the test\", \"desc\":\"The description of the test\", \"drones\":the_number_of_drones, \"test\":[ the actual test case go here ], } Within the test:[] entity we will start to define all the different test cases that want to run as part of this test. A typical testcase would look like this { \"desc\":\"use fatserver calls to set public_essid)\", \"repeat\":how_often_we_want_to_run_the_test, \"first\":loop_from_first, \"last\":loop_to_last, \"sleep\":how_many_seconds_to_sleep_after_the_test, \"cmd\":[ the actual commands to be called go here ], } If last/first is set, repeat will be ignored. Within the cmd:[] entity we define the actual real commands that we want the drone to execute as part of the test. Consider these to be a reduced to the smallest denominator of commands called (or in other terms, these are risc commands and not cisc). The command can have a verity of functions, from setting local and remote network settings, doing a generic sleep, talking to the DUT, doing random networkery, ... Lets start by looking at a single row [ \"ACTION\", .................. ] Every line start with a ACTION. Depending on the real ACTION to take, we can have N parameters following the ACTON call. Actions can be of 3 types. So lets look at 3 lines { [ \"sleep\", 5 ], [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], [ \"essid\", 1, \"foorandom\", \"12345321234\" ], } sleep - sleep # this makes the system wait 5 seconds [ \"sleep\", 5 ] drone - send commands to drone # we want to send a command to a drone, whose id is 1, the commands id is # \"webui_auth\" and we pass the payload {\"pass\":\"foobar\"}. if the call fails # to return within 300s, we raise a failure/exception [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], $complex - when ACTIONS become to complex to be handled by the \"drone\" call, we can add additional handlers inside qa.py to abstract the complexion away abit. # run the complex command essid. this sets the essid of drone 1 to # foorandom and uses 12345321234 as a passphrase this call is complex as we # don't only send a command, but 2 and then poll for their completion. # Completion is detected by polling the network status reporting info from # the DUT [ \"essid\", 1, \"foorandom\", \"12345321234\" ] All complex functions are located inside qa.py A full test would look like this: { \"id\":\"test123\", \"desc\":\"A demo testcase.\", \"drones\":1, \"test\": [ { \"desc\":\"log into webui and set essid\", \"repeat\":1, \"sleep\":1, \"cmd\": [ { [ \"sleep\", 5 ], [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], [ \"essid\", 1, \"foorandom\", \"12345321234\" ], } ], }, ], } Using iterations and substitution \u00b6 As described above a test set can be repeated N times (repeat: 4). To reflect the N iterations within the test we can use variable substitution. To do so, simply place $iterate inside any parameter section and it will get magically replaced by the backend. A simple iteration example would look like this. { \"id\":\"example.iterate\", \"desc\":\"Demo of how iterate works\", \"drones\":1, \"test\":[ {\"desc\":\"repeat example\", \"repeat\":4, \"sleep\":2, \"cmd\":[ [ \"comment\", \"Iteration $iterate\" ] ] } ] } --> RUN \"iterate\" - iteration 1 COMMENT Iteration 1 RUN \"iterate\" - iteration 2 COMMENT Iteration 2 RUN \"iterate\" - iteration 3 COMMENT Iteration 3 RUN \"iterate\" - iteration 4 COMMENT Iteration 4 { \"id\":\"example.iterate\", \"desc\":\"Demo of how iterate works\", \"drones\":1, \"test\":[ {\"desc\":\"first->last example\", \"first\":4, \"last\":\"6, \"sleep\":2, \"cmd\":[ [ \"comment\", \"Iteration $iterate\" ] ] } ] } --> RUN \"iterate\" - iteration 4 COMMENT Iteration 4 RUN \"iterate\" - iteration 5 COMMENT Iteration 5 RUN \"iterate\" - iteration 6 COMMENT Iteration 6 In addition we can use variable substation. To do so simply create a new value inside conf.py and then reference it inside your json code [ \"drone\", 1, \"cloudlogin\", {\"user\":\"$cloud_user\", \"pass\":\"$cloud_pass\", \"host\":\"$cloud_url\"}, 300 ] List of all complex calls \u00b6 Generally we use complex calls whenever we need to not just send data but wait for a status. # set a static IP on drone 1 [ \"static\", 1, \"192.168.10.2\", \"255.255.255.0\" ] # set essid of drone 1 to wifitest and wpa key to foobar [ \"essid\", 1, \"wifitest\", \"foobar\" ] # trigger drone 1 [ \"dhcp\", 1 ] # sleep 5 seconds [ \"sleep\", 1 ] # fail is a test result inverter. it switces a result true<->false [ \"fail\", \"dhcp\", 1 ] # this will trigger qa.py to print a comment in the log [ \"comment\", \"foooooobar\" ] # this will cause drone 1 to try and ping a remote url [ \"ping\", 1, \"192.168.10.1\" ] # this will check if the IP received in a dhcp reply received by drone 1 # matches certain criterions. [ \"checkip\", 1, \"192.168.10.\" ] As netmasks are limited to 32 and or not always obvious which once are valid, we have 2 special complex calls to handle this. Netmasks are always indexed by an id rather than a absolute mask. # this will set the netmask on drone 1 to Mask index #1 [ \"setnetmask\", 1 ] # this will check if the netmask received in a dhcp reply received by drone 1 # matches certain criterions of Mask index #1 [ \"checknetmask\", 1 ] Finally we have a complex call that we use as our entry point for RPC on a Drone # send a drone RPC call to drone 1. [ \"drone\", 1, \"webui_auth\", {\"pass\":\"admin\"}, 300 ], List of all drone calls \u00b6 # dns_flood - do mass dns resolving [ \"drone\", 1, \"dns_flood\", [\"www.google.de\", \"www.google.com\"] # download - download a file and check its size [ \"drone\", 1, \"download\", {\"url\":\"http://dev.phrozen.org/test\", \"repeat\":\"4\", \"size\":\"1048576\"}, 300 ] # fatserver - simulate a fatserver call - this requires a DUT with dev mode enabled [ \"drone\", 1, \"fatserver\", {\"host\":\"192.168.10.1\", \"payload\":\"json|{\\\"cmd\\\":\\\"setwpapassword\\\", \\\"val\\\":\\\"12345321234\\\" }\" } ] # cloudlogin - log into a cloudspot using http redirects [ \"drone\", 1, \"cloudlogin\", {\"user\":\"$cloud_user\", \"pass\":\"$cloud_pass\", \"host\":\"$cloud_url\"}, 300 ] # cloudwispr - log into a cloudspot using wispr # cloudlogout - log of the cloud service [ \"drone\", 1, \"cloudlogout\" ] # webui_auth - tell the drone to log into the DUTs webui [ \"drone\", 1, \"webui_auth\", {\"pass\":\"admin\"}, 300 ] # webui_rpc - send a webui rpc call (these are identical to the ones used by the normal webui) [ \"drone\", 1, \"webui_rpc\", { \"set\":\"passwd\", \"vals\":{\"passwd1\":\"fooooooooo\" } } ], # webui_deauth - log off the webui [ \"drone\", 1, \"webui_deauth\" ] # webui_ip - use a different webui ip than 192.168.10.1 [ \"drone\", 1, \"webui_ip\", {\"ipaddr\":\"169.254.255.1\"}, 300 ], # uci_dump - get [ \"drone\", 1, \"uci_dump\", {\"package\":\"cloud\", \"section\":\"state\", \"state\":1 }, 300 ], The following calls exist but are currently unused getifaddrs - get a list of all netdevs inclusive the ipaddr ... readfile - read a random file from the drones FS reset - reboot the drone sysinfo - get system resource usage system - execute a random system call on the drone uci_dump - get some use values uci_replace - uci magic upgrade - FW upgrade of the Drone","title":"udrone - QA done right"},{"location":"#udrone-qa-done-right","text":"Udrone is a system that allows you to remotely control N drones. The N drones can be sent a number of different commands. Based on these commands the drone will perform a number of actions and report the result back to the drone host controller. The system consists of a number of files on the controller side. udronerc.py - the core component. This code establishes a communication channel to the drone. qa.py - this is a wrapper for udrone.py that allows us to write test in json syntax and run them in a sane manner *.yml - this is a collection of predefined tests, that the drone can run","title":"udrone - QA done right"},{"location":"#setup","text":"The following steps explain how to setup an udrone environment.","title":"Setup"},{"location":"#where-do-i-get-udrone","text":"Checkout the latest version via the following command $ git clone https://github.com/blogic/udrone","title":"Where do I get udrone"},{"location":"#how-do-i-setup-udrone-software","text":"udrone is easy to setup. All custom information is stored in a central file called config.py $ cat config.py ifname: eth0 # the interface used to talk to the drones","title":"How do I setup udrone software"},{"location":"#hardware-setup","text":"In addition to the device under testing (DUT) you will need N drones. A drone is a OpenWrt router with the udrone package installed. Once you have all devices, you need to set them up in 1 of the following ways. LAPTOP (eth0) -> (LAN) DRONE (WAN) -> (LAN) DUT (WAN) -> BACKEND LAPTOP (eth0) -> (LAN) DRONE (WIFI) -> (WIFI) DUT (WAN) -> BACKEND If you want to use more than just 1 Drone you will need to switches between LAPTOP/DRONE and DRONE/DUT . As a backend you will need, depending on the test: AP/PPPoE Server/DHCP/DNS/...","title":"Hardware setup"},{"location":"#run-tests","text":"The simplest test is the connectivity test. This will make the drone grab an IPV4 using DHCP from the DUT and wget http://openwrt.org/index.html . $ ./qa.py test/connectivity.yml Once all test are run, the qa tool will report back if the test passed or failed.","title":"Run tests"},{"location":"#definition-of-test-cases","text":"So, lets start by looking at the format of the json file. The basic layout of any json based test description is as follows { \"id\":\"The ID of the test\", \"desc\":\"The description of the test\", \"drones\":the_number_of_drones, \"test\":[ the actual test case go here ], } Within the test:[] entity we will start to define all the different test cases that want to run as part of this test. A typical testcase would look like this { \"desc\":\"use fatserver calls to set public_essid)\", \"repeat\":how_often_we_want_to_run_the_test, \"first\":loop_from_first, \"last\":loop_to_last, \"sleep\":how_many_seconds_to_sleep_after_the_test, \"cmd\":[ the actual commands to be called go here ], } If last/first is set, repeat will be ignored. Within the cmd:[] entity we define the actual real commands that we want the drone to execute as part of the test. Consider these to be a reduced to the smallest denominator of commands called (or in other terms, these are risc commands and not cisc). The command can have a verity of functions, from setting local and remote network settings, doing a generic sleep, talking to the DUT, doing random networkery, ... Lets start by looking at a single row [ \"ACTION\", .................. ] Every line start with a ACTION. Depending on the real ACTION to take, we can have N parameters following the ACTON call. Actions can be of 3 types. So lets look at 3 lines { [ \"sleep\", 5 ], [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], [ \"essid\", 1, \"foorandom\", \"12345321234\" ], } sleep - sleep # this makes the system wait 5 seconds [ \"sleep\", 5 ] drone - send commands to drone # we want to send a command to a drone, whose id is 1, the commands id is # \"webui_auth\" and we pass the payload {\"pass\":\"foobar\"}. if the call fails # to return within 300s, we raise a failure/exception [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], $complex - when ACTIONS become to complex to be handled by the \"drone\" call, we can add additional handlers inside qa.py to abstract the complexion away abit. # run the complex command essid. this sets the essid of drone 1 to # foorandom and uses 12345321234 as a passphrase this call is complex as we # don't only send a command, but 2 and then poll for their completion. # Completion is detected by polling the network status reporting info from # the DUT [ \"essid\", 1, \"foorandom\", \"12345321234\" ] All complex functions are located inside qa.py A full test would look like this: { \"id\":\"test123\", \"desc\":\"A demo testcase.\", \"drones\":1, \"test\": [ { \"desc\":\"log into webui and set essid\", \"repeat\":1, \"sleep\":1, \"cmd\": [ { [ \"sleep\", 5 ], [ \"drone\", 1, \"webui_auth\", {\"pass\":\"foobar\"}, 300 ], [ \"essid\", 1, \"foorandom\", \"12345321234\" ], } ], }, ], }","title":"Definition of test cases"},{"location":"#using-iterations-and-substitution","text":"As described above a test set can be repeated N times (repeat: 4). To reflect the N iterations within the test we can use variable substitution. To do so, simply place $iterate inside any parameter section and it will get magically replaced by the backend. A simple iteration example would look like this. { \"id\":\"example.iterate\", \"desc\":\"Demo of how iterate works\", \"drones\":1, \"test\":[ {\"desc\":\"repeat example\", \"repeat\":4, \"sleep\":2, \"cmd\":[ [ \"comment\", \"Iteration $iterate\" ] ] } ] } --> RUN \"iterate\" - iteration 1 COMMENT Iteration 1 RUN \"iterate\" - iteration 2 COMMENT Iteration 2 RUN \"iterate\" - iteration 3 COMMENT Iteration 3 RUN \"iterate\" - iteration 4 COMMENT Iteration 4 { \"id\":\"example.iterate\", \"desc\":\"Demo of how iterate works\", \"drones\":1, \"test\":[ {\"desc\":\"first->last example\", \"first\":4, \"last\":\"6, \"sleep\":2, \"cmd\":[ [ \"comment\", \"Iteration $iterate\" ] ] } ] } --> RUN \"iterate\" - iteration 4 COMMENT Iteration 4 RUN \"iterate\" - iteration 5 COMMENT Iteration 5 RUN \"iterate\" - iteration 6 COMMENT Iteration 6 In addition we can use variable substation. To do so simply create a new value inside conf.py and then reference it inside your json code [ \"drone\", 1, \"cloudlogin\", {\"user\":\"$cloud_user\", \"pass\":\"$cloud_pass\", \"host\":\"$cloud_url\"}, 300 ]","title":"Using iterations and substitution"},{"location":"#list-of-all-complex-calls","text":"Generally we use complex calls whenever we need to not just send data but wait for a status. # set a static IP on drone 1 [ \"static\", 1, \"192.168.10.2\", \"255.255.255.0\" ] # set essid of drone 1 to wifitest and wpa key to foobar [ \"essid\", 1, \"wifitest\", \"foobar\" ] # trigger drone 1 [ \"dhcp\", 1 ] # sleep 5 seconds [ \"sleep\", 1 ] # fail is a test result inverter. it switces a result true<->false [ \"fail\", \"dhcp\", 1 ] # this will trigger qa.py to print a comment in the log [ \"comment\", \"foooooobar\" ] # this will cause drone 1 to try and ping a remote url [ \"ping\", 1, \"192.168.10.1\" ] # this will check if the IP received in a dhcp reply received by drone 1 # matches certain criterions. [ \"checkip\", 1, \"192.168.10.\" ] As netmasks are limited to 32 and or not always obvious which once are valid, we have 2 special complex calls to handle this. Netmasks are always indexed by an id rather than a absolute mask. # this will set the netmask on drone 1 to Mask index #1 [ \"setnetmask\", 1 ] # this will check if the netmask received in a dhcp reply received by drone 1 # matches certain criterions of Mask index #1 [ \"checknetmask\", 1 ] Finally we have a complex call that we use as our entry point for RPC on a Drone # send a drone RPC call to drone 1. [ \"drone\", 1, \"webui_auth\", {\"pass\":\"admin\"}, 300 ],","title":"List of all complex calls"},{"location":"#list-of-all-drone-calls","text":"# dns_flood - do mass dns resolving [ \"drone\", 1, \"dns_flood\", [\"www.google.de\", \"www.google.com\"] # download - download a file and check its size [ \"drone\", 1, \"download\", {\"url\":\"http://dev.phrozen.org/test\", \"repeat\":\"4\", \"size\":\"1048576\"}, 300 ] # fatserver - simulate a fatserver call - this requires a DUT with dev mode enabled [ \"drone\", 1, \"fatserver\", {\"host\":\"192.168.10.1\", \"payload\":\"json|{\\\"cmd\\\":\\\"setwpapassword\\\", \\\"val\\\":\\\"12345321234\\\" }\" } ] # cloudlogin - log into a cloudspot using http redirects [ \"drone\", 1, \"cloudlogin\", {\"user\":\"$cloud_user\", \"pass\":\"$cloud_pass\", \"host\":\"$cloud_url\"}, 300 ] # cloudwispr - log into a cloudspot using wispr # cloudlogout - log of the cloud service [ \"drone\", 1, \"cloudlogout\" ] # webui_auth - tell the drone to log into the DUTs webui [ \"drone\", 1, \"webui_auth\", {\"pass\":\"admin\"}, 300 ] # webui_rpc - send a webui rpc call (these are identical to the ones used by the normal webui) [ \"drone\", 1, \"webui_rpc\", { \"set\":\"passwd\", \"vals\":{\"passwd1\":\"fooooooooo\" } } ], # webui_deauth - log off the webui [ \"drone\", 1, \"webui_deauth\" ] # webui_ip - use a different webui ip than 192.168.10.1 [ \"drone\", 1, \"webui_ip\", {\"ipaddr\":\"169.254.255.1\"}, 300 ], # uci_dump - get [ \"drone\", 1, \"uci_dump\", {\"package\":\"cloud\", \"section\":\"state\", \"state\":1 }, 300 ], The following calls exist but are currently unused getifaddrs - get a list of all netdevs inclusive the ipaddr ... readfile - read a random file from the drones FS reset - reboot the drone sysinfo - get system resource usage system - execute a random system call on the drone uci_dump - get some use values uci_replace - uci magic upgrade - FW upgrade of the Drone","title":"List of all drone calls"},{"location":"reference/qa/","text":"cmd_comment(args, counter) \u00b6 Show source code in /udronerc/qa.py def cmd_comment(args, counter): \"\"\" Print comment inside the log Args: args (dict): must contain msg which will be logger.debuged counter (int): current interation in loop \"\"\" comment = replace_tags(args[\"msg\"], counter) logger.debug(f\"COMMENT {comment}\") Print comment inside the log Parameters Name Type Description Default args _empty must contain msg which will be logger.debuged required counter _empty current interation in loop required cmd_sleep(v, c) \u00b6 Show source code in /udronerc/qa.py def cmd_sleep(v, c): \"\"\" Sleep for N seconds Args: v: seconds to sleep c: unused \"\"\" logger.debug(f\"SLEEP {v[1]:d}\") time.sleep(v[1]) Sleep for N seconds Parameters Name Type Description Default v _empty seconds to sleep required c _empty unused required online_drones() \u00b6 Show source code in /udronerc/qa.py def online_drones(): \"\"\"Prints list of currently online drones\"\"\" online = host.whois(\"!all-default\") logger.debug((online)) if not online: logger.debug(\"No drones found!\") else: logger.debug(f\"Online drones: {len(online)}\") for drone in online.values(): logger.debug(drone) data = drone[\"data\"] logger.debug(f\"Drone {drone['from']} ({data['board']}) is online \") Prints list of currently online drones replace_tags(msg, data) \u00b6 Show source code in /udronerc/qa.py def replace_tags(msg: str, data: dict): \"\"\"Replaces values inside parameters based on conf.py Args: msg (str): Message containing tags data (dict): Mapping for tags \"\"\" return msg.format(*data) Replaces values inside parameters based on conf.py Parameters Name Type Description Default msg (str): Message containing tags data (dict): Mapping for tags run_task_drone(task) \u00b6 Show source code in /udronerc/qa.py def run_task_drone(task): \"\"\" Run a task remotely on udrone Args: task (dict): Task to run on drone \"\"\" task_id, task_data = validate_task(task, cmds_drone) # TODO validate task args # per default we wait 10s for a reply timeout = 10 # if a timeout value was passed, use it instead of the default if len(v) == 5: timeout = v[4] # check if the call has a payload if len(v) < 4: # no payload so do a flat call logger.debug('DRONE calling \"' + v[2] + '\"') return drone[v[1] - 1].call(v[2]) else: # there is a payload, substitue global vars and iteration coutners payload = replace_tags(v[3], c) # issue the actual command logger.debug('DRONE calling \"' + v[2] + '\":' + json.dumps(payload)) return drone[v[1] - 1].call(v[2], payload, task.get(\"timeout\", 10)) return cmd_drone Run a task remotely on udrone Parameters Name Type Description Default task _empty Task to run on drone required run_task_local(task) \u00b6 Show source code in /udronerc/qa.py def run_task_local(task): \"\"\" Run a task locally on the udrone host Args: task (dict): Task to run locally \"\"\" task_id, task_data = validate_task(task, cmd_local_map.keys()) return cmd_local_map[task_id](task_data) Run a task locally on the udrone host Parameters Name Type Description Default task _empty Task to run locally required run_test(test) \u00b6 Show source code in /udronerc/qa.py def run_test(test): \"\"\" Run a actual test Args: test (test): the test to run \"\"\" max = 1 loop = 0 # we can iterate 0->max try: if test[\"repeat\"] is not None: max = test[\"repeat\"] except: max = 1 # or we iterate 0/first -> last try: if test[\"last\"] is not None: max = test[\"last\"] if test[\"first\"] is not None: loop = test[\"first\"] loop = loop - 1 except: loop = 0 # do $max iterations of the test set fail = 0 while loop < max: loop = loop + 1 logger.debug('RUN \"' + test[\"desc\"] + f'\" - iteration {loop:d}') try: # loop over all commands and call them for task in test[\"tasks\"]: if task.get(\"local\", False): res = run_task_local(task) else: res = run_task_drone(task) res = cmd_map[task[0]](task, loop) except KeyboardInterrupt as e: # ctrl-C was hit exit(-1) except: # increment fail counter fail = fail + 1 logger.debug(f\"FAIL iterate {loop:d}\") logger.debug(sys.exc_info()) if fail > 0: raise ExceptionClass(1000, f\"{fail:d} iterations failed\", \"foo\") Run a actual test Parameters Name Type Description Default test _empty the test to run required","title":"Qa"},{"location":"reference/qa/#udronerc.qa.cmd_comment","text":"Show source code in /udronerc/qa.py def cmd_comment(args, counter): \"\"\" Print comment inside the log Args: args (dict): must contain msg which will be logger.debuged counter (int): current interation in loop \"\"\" comment = replace_tags(args[\"msg\"], counter) logger.debug(f\"COMMENT {comment}\") Print comment inside the log Parameters Name Type Description Default args _empty must contain msg which will be logger.debuged required counter _empty current interation in loop required","title":"cmd_comment()"},{"location":"reference/qa/#udronerc.qa.cmd_sleep","text":"Show source code in /udronerc/qa.py def cmd_sleep(v, c): \"\"\" Sleep for N seconds Args: v: seconds to sleep c: unused \"\"\" logger.debug(f\"SLEEP {v[1]:d}\") time.sleep(v[1]) Sleep for N seconds Parameters Name Type Description Default v _empty seconds to sleep required c _empty unused required","title":"cmd_sleep()"},{"location":"reference/qa/#udronerc.qa.online_drones","text":"Show source code in /udronerc/qa.py def online_drones(): \"\"\"Prints list of currently online drones\"\"\" online = host.whois(\"!all-default\") logger.debug((online)) if not online: logger.debug(\"No drones found!\") else: logger.debug(f\"Online drones: {len(online)}\") for drone in online.values(): logger.debug(drone) data = drone[\"data\"] logger.debug(f\"Drone {drone['from']} ({data['board']}) is online \") Prints list of currently online drones","title":"online_drones()"},{"location":"reference/qa/#udronerc.qa.replace_tags","text":"Show source code in /udronerc/qa.py def replace_tags(msg: str, data: dict): \"\"\"Replaces values inside parameters based on conf.py Args: msg (str): Message containing tags data (dict): Mapping for tags \"\"\" return msg.format(*data) Replaces values inside parameters based on conf.py Parameters Name Type Description Default msg (str): Message containing tags data (dict): Mapping for tags","title":"replace_tags()"},{"location":"reference/qa/#udronerc.qa.run_task_drone","text":"Show source code in /udronerc/qa.py def run_task_drone(task): \"\"\" Run a task remotely on udrone Args: task (dict): Task to run on drone \"\"\" task_id, task_data = validate_task(task, cmds_drone) # TODO validate task args # per default we wait 10s for a reply timeout = 10 # if a timeout value was passed, use it instead of the default if len(v) == 5: timeout = v[4] # check if the call has a payload if len(v) < 4: # no payload so do a flat call logger.debug('DRONE calling \"' + v[2] + '\"') return drone[v[1] - 1].call(v[2]) else: # there is a payload, substitue global vars and iteration coutners payload = replace_tags(v[3], c) # issue the actual command logger.debug('DRONE calling \"' + v[2] + '\":' + json.dumps(payload)) return drone[v[1] - 1].call(v[2], payload, task.get(\"timeout\", 10)) return cmd_drone Run a task remotely on udrone Parameters Name Type Description Default task _empty Task to run on drone required","title":"run_task_drone()"},{"location":"reference/qa/#udronerc.qa.run_task_local","text":"Show source code in /udronerc/qa.py def run_task_local(task): \"\"\" Run a task locally on the udrone host Args: task (dict): Task to run locally \"\"\" task_id, task_data = validate_task(task, cmd_local_map.keys()) return cmd_local_map[task_id](task_data) Run a task locally on the udrone host Parameters Name Type Description Default task _empty Task to run locally required","title":"run_task_local()"},{"location":"reference/qa/#udronerc.qa.run_test","text":"Show source code in /udronerc/qa.py def run_test(test): \"\"\" Run a actual test Args: test (test): the test to run \"\"\" max = 1 loop = 0 # we can iterate 0->max try: if test[\"repeat\"] is not None: max = test[\"repeat\"] except: max = 1 # or we iterate 0/first -> last try: if test[\"last\"] is not None: max = test[\"last\"] if test[\"first\"] is not None: loop = test[\"first\"] loop = loop - 1 except: loop = 0 # do $max iterations of the test set fail = 0 while loop < max: loop = loop + 1 logger.debug('RUN \"' + test[\"desc\"] + f'\" - iteration {loop:d}') try: # loop over all commands and call them for task in test[\"tasks\"]: if task.get(\"local\", False): res = run_task_local(task) else: res = run_task_drone(task) res = cmd_map[task[0]](task, loop) except KeyboardInterrupt as e: # ctrl-C was hit exit(-1) except: # increment fail counter fail = fail + 1 logger.debug(f\"FAIL iterate {loop:d}\") logger.debug(sys.exc_info()) if fail > 0: raise ExceptionClass(1000, f\"{fail:d} iterations failed\", \"foo\") Run a actual test Parameters Name Type Description Default test _empty the test to run required","title":"run_test()"},{"location":"reference/udronerc/","text":"DroneGroup \u00b6 assign(self, max_nodes, min_nodes=None, board=None) \u00b6 Show source code in /udronerc/udronerc.py def assign(self, max_nodes: int, min_nodes: int = None, board: str = None) -> list: \"\"\" Assign nodes to group Args: max_nodes (int): maximal number of nodes required min_nodes (int): mimimal number of nodes required board (str): limit assignment to specific board Returns: list: new member os group \"\"\" if not min_nodes: min_nodes = max_nodes if max_nodes else 1 available = self.host.whois( UDRONE_GROUP_DEFAULT, max_nodes, board=board ).keys()[:max_nodes] if len(available) < min_nodes: raise DroneNotFoundError((ENOENT, \"You must construct additional drones\")) new_members = self.engage(available) if len(new_members) < min_nodes: max_nodes -= len(new_members) available = self.host.whois(UDRONE_GROUP_DEFAULT, max_nodes).keys()[ :max_nodes ] new_members += self.engage(available) if len(new_members) < min_nodes: if len(new_members) > 0: # Rollback self.host.call_multi(new_members, None, \"!reset\", None, \"status\") raise DroneNotFoundError((ENOENT, \"You must construct additional drones\")) return new_members Assign nodes to group Parameters Name Type Description Default max_nodes int maximal number of nodes required required min_nodes int mimimal number of nodes required None board str limit assignment to specific board None Returns Type Description list list: new member os group DroneHost \u00b6 call(self, to, seq, msg_type, data=None, resp_type=None, expect=None) \u00b6 Show source code in /udronerc/udronerc.py def call( self, to: str, seq: int, msg_type: str, data: dict = None, resp_type: str = None, expect: list = None, ) -> dict: \"\"\" Send data to drone and receive response Args: to (str): selected group seq (int): sequence number msg_type (str): send message of type data (dict): data to send to group resp_type (str): receive message of type expect (list): list of drones expected to anser Returns: dict: received message from drones \"\"\" if not seq: seq = self.genseq() answers = {} for timeout in self.resent_strategy: self.send(to, seq, msg_type, data) self.recv_until(answers, seq, resp_type, timeout, expect) if expect is not None and len(expect) == 0: break return answers Send data to drone and receive response Parameters Name Type Description Default to str selected group required seq int sequence number required msg_type str send message of type required data dict data to send to group None resp_type str receive message of type None expect list list of drones expected to anser None Returns Type Description dict dict: received message from drones call_multi(self, nodes, seq, msg_type, data=None, resp_type=None) \u00b6 Show source code in /udronerc/udronerc.py def call_multi( self, nodes: list, seq: int, msg_type: str, data: dict = None, resp_type: str = None, ) -> dict: \"\"\" Send data to multiple drones and receive responses Args: nodes (list): selected drones seq (int): sequence number msg_type (str): send message of type data (dict): data to send to group resp_type (str): receive message of type Returns: dict: received message from drones \"\"\" if not seq: seq = self.genseq() answers = {} for timeout in self.resent_strategy: for node in nodes: self.send(node, seq, msg_type, data) self.recv_until(answers, seq, resp_type, timeout, nodes) if len(nodes) == 0: break return answers Send data to multiple drones and receive responses Parameters Name Type Description Default nodes list selected drones required seq int sequence number required msg_type str send message of type required data dict data to send to group None resp_type str receive message of type None Returns Type Description dict dict: received message from drones genseq(self) \u00b6 Show source code in /udronerc/udronerc.py def genseq(self) -> int: \"\"\" Generate random sequence number Returns: int: generated sequence \"\"\" return struct.unpack(\"=I\", os.urandom(4))[0] % 2000000000 Generate random sequence number Returns Type Description int int: generated sequence get_ip_address(self, interface) \u00b6 Show source code in /udronerc/udronerc.py def get_ip_address(self, interface: str) -> str: \"\"\" Get IP of a local interface Args: interface (str): name of local interface Returns: str: IP address of interface \"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) return socket.inet_ntoa( fcntl.ioctl( s.fileno(), 0x8915, struct.pack(\"256s\", interface[:15].encode(\"utf-8\")), # SIOCGIFADDR )[20:24] ) Get IP of a local interface Parameters Name Type Description Default interface str name of local interface required Returns Type Description str str: IP address of interface recv(self, seq, msg_type=None) \u00b6 Show source code in /udronerc/udronerc.py def recv(self, seq: int, msg_type: str = None) -> dict: \"\"\" Recevie messages from drones Args: seq (int): sequence number msg_type (str): type of message to receive Returns: dict: received message from drone \"\"\" while True: try: msg = json.loads(self.socket.recv(self.maxsize)) if ( msg[\"from\"] and msg[\"type\"] and msg[\"to\"] == self.uniqueid and (not msg_type or msg[\"type\"] == msg_type) and (not seq or msg[\"seq\"] == seq) ): logger.debug(\"Received: %s\", str(msg)) return msg except Exception as e: if isinstance(e, socket.error) and e.errno == EWOULDBLOCK: return None Recevie messages from drones Parameters Name Type Description Default seq int sequence number required msg_type str type of message to receive None Returns Type Description dict dict: received message from drone recv_until(self, answers, seq, msg_type=None, timeout=1, expect=None) \u00b6 Show source code in /udronerc/udronerc.py def recv_until( self, answers: dict, seq: int, msg_type: str = None, timeout: int = 1, expect: list = None, ): \"\"\" Recevie messages from drones until requirement is fulfilled Args: answers (dict): Empty dict to be filled with received answers seq (int): sequence number msg_type (str): type of message to receive timeout (int): number of seconds before receiving timeouts expect (list): list of drones expected to anser \"\"\" logger.debug( \"Receiving replies for seq %i for %.1f secs expecting %s\", seq, timeout, expect, ) start = time.time() now = start while ( (now - start) >= 0 and (now - start) < timeout and (expect is None or len(expect) > 0) ): self.poll.poll((timeout - (now - start)) * 1000) while True: msg = self.recv(seq, msg_type) if msg: answers[msg[\"from\"]] = msg if expect is not None and msg[\"from\"] in expect: expect.remove(msg[\"from\"]) elif not msg: break now = time.time() Recevie messages from drones until requirement is fulfilled Parameters Name Type Description Default answers dict Empty dict to be filled with received answers required seq int sequence number required msg_type str type of message to receive None timeout int number of seconds before receiving timeouts 1 expect list list of drones expected to anser None send(self, to, seq, msg_type, data=None) \u00b6 Show source code in /udronerc/udronerc.py def send(self, to: str, seq: int, msg_type: str, data: dict = None): \"\"\" Send message to drone Args: to (str): receiving group seq (int): sequence number msg_type (str): type of message to receive data (dict): data to send to node \"\"\" msg = {\"from\": self.uniqueid, \"to\": to, \"type\": msg_type, \"seq\": seq} if data is not None: msg[\"data\"] = data packet = json.dumps(msg, separators=(\",\", \":\")) logger.debug(f\"Sending: {packet}\") self.socket.sendto(packet.encode(\"utf-8\"), self.addr) Send message to drone Parameters Name Type Description Default to str receiving group required seq int sequence number required msg_type str type of message to receive required data dict data to send to node None whois(self, group, need=None, seq=None, board=None) \u00b6 Show source code in /udronerc/udronerc.py def whois( self, group: str, need: int = None, seq: int = None, board: str = None ) -> dict: \"\"\" Return online drones Args: group (str): limit request to specific group need (int): minimum number of ansers seq (int): sequence number board (str): limit request to specific board Returns: dict: received answers of boards \"\"\" answers = {} if seq is None: seq = self.genseq() for timeout in self.resent_strategy: data = {} if board: data[\"board\"] = board self.send(group, seq, \"!whois\", data) if need == 0: break self.recv_until(answers, seq, \"status\", timeout) if need and len(answers) >= need: break return answers Return online drones Parameters Name Type Description Default group str limit request to specific group required need int minimum number of ansers None seq int sequence number None board str limit request to specific board None Returns Type Description dict dict: received answers of boards","title":"Udronerc"},{"location":"reference/udronerc/#udronerc.udronerc.DroneGroup","text":"","title":"DroneGroup"},{"location":"reference/udronerc/#udronerc.udronerc.DroneGroup.assign","text":"Show source code in /udronerc/udronerc.py def assign(self, max_nodes: int, min_nodes: int = None, board: str = None) -> list: \"\"\" Assign nodes to group Args: max_nodes (int): maximal number of nodes required min_nodes (int): mimimal number of nodes required board (str): limit assignment to specific board Returns: list: new member os group \"\"\" if not min_nodes: min_nodes = max_nodes if max_nodes else 1 available = self.host.whois( UDRONE_GROUP_DEFAULT, max_nodes, board=board ).keys()[:max_nodes] if len(available) < min_nodes: raise DroneNotFoundError((ENOENT, \"You must construct additional drones\")) new_members = self.engage(available) if len(new_members) < min_nodes: max_nodes -= len(new_members) available = self.host.whois(UDRONE_GROUP_DEFAULT, max_nodes).keys()[ :max_nodes ] new_members += self.engage(available) if len(new_members) < min_nodes: if len(new_members) > 0: # Rollback self.host.call_multi(new_members, None, \"!reset\", None, \"status\") raise DroneNotFoundError((ENOENT, \"You must construct additional drones\")) return new_members Assign nodes to group Parameters Name Type Description Default max_nodes int maximal number of nodes required required min_nodes int mimimal number of nodes required None board str limit assignment to specific board None Returns Type Description list list: new member os group","title":"assign()"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost","text":"","title":"DroneHost"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost.call","text":"Show source code in /udronerc/udronerc.py def call( self, to: str, seq: int, msg_type: str, data: dict = None, resp_type: str = None, expect: list = None, ) -> dict: \"\"\" Send data to drone and receive response Args: to (str): selected group seq (int): sequence number msg_type (str): send message of type data (dict): data to send to group resp_type (str): receive message of type expect (list): list of drones expected to anser Returns: dict: received message from drones \"\"\" if not seq: seq = self.genseq() answers = {} for timeout in self.resent_strategy: self.send(to, seq, msg_type, data) self.recv_until(answers, seq, resp_type, timeout, expect) if expect is not None and len(expect) == 0: break return answers Send data to drone and receive response Parameters Name Type Description Default to str selected group required seq int sequence number required msg_type str send message of type required data dict data to send to group None resp_type str receive message of type None expect list list of drones expected to anser None Returns Type Description dict dict: received message from drones","title":"call()"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost.call_multi","text":"Show source code in /udronerc/udronerc.py def call_multi( self, nodes: list, seq: int, msg_type: str, data: dict = None, resp_type: str = None, ) -> dict: \"\"\" Send data to multiple drones and receive responses Args: nodes (list): selected drones seq (int): sequence number msg_type (str): send message of type data (dict): data to send to group resp_type (str): receive message of type Returns: dict: received message from drones \"\"\" if not seq: seq = self.genseq() answers = {} for timeout in self.resent_strategy: for node in nodes: self.send(node, seq, msg_type, data) self.recv_until(answers, seq, resp_type, timeout, nodes) if len(nodes) == 0: break return answers Send data to multiple drones and receive responses Parameters Name Type Description Default nodes list selected drones required seq int sequence number required msg_type str send message of type required data dict data to send to group None resp_type str receive message of type None Returns Type Description dict dict: received message from drones","title":"call_multi()"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost.genseq","text":"Show source code in /udronerc/udronerc.py def genseq(self) -> int: \"\"\" Generate random sequence number Returns: int: generated sequence \"\"\" return struct.unpack(\"=I\", os.urandom(4))[0] % 2000000000 Generate random sequence number Returns Type Description int int: generated sequence","title":"genseq()"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost.get_ip_address","text":"Show source code in /udronerc/udronerc.py def get_ip_address(self, interface: str) -> str: \"\"\" Get IP of a local interface Args: interface (str): name of local interface Returns: str: IP address of interface \"\"\" s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) return socket.inet_ntoa( fcntl.ioctl( s.fileno(), 0x8915, struct.pack(\"256s\", interface[:15].encode(\"utf-8\")), # SIOCGIFADDR )[20:24] ) Get IP of a local interface Parameters Name Type Description Default interface str name of local interface required Returns Type Description str str: IP address of interface","title":"get_ip_address()"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost.recv","text":"Show source code in /udronerc/udronerc.py def recv(self, seq: int, msg_type: str = None) -> dict: \"\"\" Recevie messages from drones Args: seq (int): sequence number msg_type (str): type of message to receive Returns: dict: received message from drone \"\"\" while True: try: msg = json.loads(self.socket.recv(self.maxsize)) if ( msg[\"from\"] and msg[\"type\"] and msg[\"to\"] == self.uniqueid and (not msg_type or msg[\"type\"] == msg_type) and (not seq or msg[\"seq\"] == seq) ): logger.debug(\"Received: %s\", str(msg)) return msg except Exception as e: if isinstance(e, socket.error) and e.errno == EWOULDBLOCK: return None Recevie messages from drones Parameters Name Type Description Default seq int sequence number required msg_type str type of message to receive None Returns Type Description dict dict: received message from drone","title":"recv()"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost.recv_until","text":"Show source code in /udronerc/udronerc.py def recv_until( self, answers: dict, seq: int, msg_type: str = None, timeout: int = 1, expect: list = None, ): \"\"\" Recevie messages from drones until requirement is fulfilled Args: answers (dict): Empty dict to be filled with received answers seq (int): sequence number msg_type (str): type of message to receive timeout (int): number of seconds before receiving timeouts expect (list): list of drones expected to anser \"\"\" logger.debug( \"Receiving replies for seq %i for %.1f secs expecting %s\", seq, timeout, expect, ) start = time.time() now = start while ( (now - start) >= 0 and (now - start) < timeout and (expect is None or len(expect) > 0) ): self.poll.poll((timeout - (now - start)) * 1000) while True: msg = self.recv(seq, msg_type) if msg: answers[msg[\"from\"]] = msg if expect is not None and msg[\"from\"] in expect: expect.remove(msg[\"from\"]) elif not msg: break now = time.time() Recevie messages from drones until requirement is fulfilled Parameters Name Type Description Default answers dict Empty dict to be filled with received answers required seq int sequence number required msg_type str type of message to receive None timeout int number of seconds before receiving timeouts 1 expect list list of drones expected to anser None","title":"recv_until()"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost.send","text":"Show source code in /udronerc/udronerc.py def send(self, to: str, seq: int, msg_type: str, data: dict = None): \"\"\" Send message to drone Args: to (str): receiving group seq (int): sequence number msg_type (str): type of message to receive data (dict): data to send to node \"\"\" msg = {\"from\": self.uniqueid, \"to\": to, \"type\": msg_type, \"seq\": seq} if data is not None: msg[\"data\"] = data packet = json.dumps(msg, separators=(\",\", \":\")) logger.debug(f\"Sending: {packet}\") self.socket.sendto(packet.encode(\"utf-8\"), self.addr) Send message to drone Parameters Name Type Description Default to str receiving group required seq int sequence number required msg_type str type of message to receive required data dict data to send to node None","title":"send()"},{"location":"reference/udronerc/#udronerc.udronerc.DroneHost.whois","text":"Show source code in /udronerc/udronerc.py def whois( self, group: str, need: int = None, seq: int = None, board: str = None ) -> dict: \"\"\" Return online drones Args: group (str): limit request to specific group need (int): minimum number of ansers seq (int): sequence number board (str): limit request to specific board Returns: dict: received answers of boards \"\"\" answers = {} if seq is None: seq = self.genseq() for timeout in self.resent_strategy: data = {} if board: data[\"board\"] = board self.send(group, seq, \"!whois\", data) if need == 0: break self.recv_until(answers, seq, \"status\", timeout) if need and len(answers) >= need: break return answers Return online drones Parameters Name Type Description Default group str limit request to specific group required need int minimum number of ansers None seq int sequence number None board str limit request to specific board None Returns Type Description dict dict: received answers of boards","title":"whois()"}]}